<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>12면체 주사위</title>
  <style>
    body {
      background: #181818;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: Arial, sans-serif;
      margin: 0;
    }
    h1 {
      color: #FFD600;
      margin-bottom: 18px;
      font-size: 2rem;
      font-weight: bold;
      letter-spacing: 1px;
    }
    #canvas3d {
      width: 500px;
      height: 500px;
      display: block;
      background: #111;
      border-radius: 18px;
      margin-bottom: 18px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.35);
    }
    button {
      margin-bottom: 18px;
      font-size: 1.2rem;
      padding: 10px 28px;
      border-radius: 12px;
      background: #FFD600;
      color: #222;
      font-weight: bold;
      border: none;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      transition: all 0.2s;
    }
    button:hover {
      background: #FFF200;
      transform: translateY(-2px);
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }
  </style>
</head>
<body>
  <h1>12면체 주사위</h1>
  <button id="rollBtn">주사위 돌리기</button>
  <canvas id="canvas3d"></canvas>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Three.js 기본 세팅
    const canvas = document.getElementById('canvas3d');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(500, 500);
    renderer.setClearColor(0x181818, 1);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 1000);
    camera.position.set(0, 0, 8);
    camera.lookAt(0, 0, 0);

    // 12면체 생성
    const dodeGeo = new THREE.DodecahedronGeometry(1.8);
    const dodeMaterial = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      roughness: 0.3,
      metalness: 0.1,
    });
    const dodeMesh = new THREE.Mesh(dodeGeo, dodeMaterial);
    dodeMesh.castShadow = true;
    scene.add(dodeMesh);

    // 대안적인 방법: 미리 정의된 위치에 숫자 배치
    function createNumberStickersAlternative() {
      // 12면체의 각 면 중심 방향 벡터 (근사값)
      const faceDirections = [
        new THREE.Vector3(0, 1.618, 1).normalize(),
        new THREE.Vector3(0, 1.618, -1).normalize(),
        new THREE.Vector3(0, -1.618, 1).normalize(),
        new THREE.Vector3(0, -1.618, -1).normalize(),
        new THREE.Vector3(1.618, 1, 0).normalize(),
        new THREE.Vector3(1.618, -1, 0).normalize(),
        new THREE.Vector3(-1.618, 1, 0).normalize(),
        new THREE.Vector3(-1.618, -1, 0).normalize(),
        new THREE.Vector3(1, 0, 1.618).normalize(),
        new THREE.Vector3(-1, 0, 1.618).normalize(),
        new THREE.Vector3(1, 0, -1.618).normalize(),
        new THREE.Vector3(-1, 0, -1.618).normalize(),
      ];

      faceDirections.forEach((direction, index) => {
        // 숫자 텍스처 생성
        const canvas = document.createElement('canvas');
        const size = 256;
        canvas.width = canvas.height = size;
        const ctx = canvas.getContext('2d');

        // 배경 (반투명 원)
        ctx.fillStyle = 'rgba(255, 214, 0, 0.9)';
        ctx.beginPath();
        ctx.arc(size / 2, size / 2, size / 2 - 10, 0, Math.PI * 2);
        ctx.fill();

        // 숫자 텍스트
        ctx.fillStyle = '#ff0000';
        ctx.font = 'bold 120px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(index + 1), size / 2, size / 2);

        // 테두리
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(size / 2, size / 2, size / 2 - 10, 0, Math.PI * 2);
        ctx.stroke();

        const texture = new THREE.CanvasTexture(canvas);

        // 스티커 메쉬 생성
        const stickerGeo = new THREE.PlaneGeometry(0.8, 0.8);
        const stickerMat = new THREE.MeshBasicMaterial({
          map: texture,
          transparent: true,
          side: THREE.DoubleSide,
        });

        const sticker = new THREE.Mesh(stickerGeo, stickerMat);

        // 스티커 위치 설정
        const stickerPos = direction.clone().multiplyScalar(1.85);
        sticker.position.copy(stickerPos);

        // 스티커가 중심을 향하도록 회전
        sticker.lookAt(0, 0, 0);

        // 스티커를 주사위의 자식으로 추가 (함께 회전하도록)
        dodeMesh.add(sticker);
      });
    }

    // 숫자 스티커 생성 (대안적 방법 사용)
    createNumberStickersAlternative();

    // 윤곽선 추가 (주사위의 자식으로)
    const edges = new THREE.EdgesGeometry(dodeGeo);
    const line = new THREE.LineSegments(
      edges,
      new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 1 })
    );
    dodeMesh.add(line);

    // 조명 설정
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 5, 5);
    directionalLight.castShadow = true;
    scene.add(directionalLight);

    // 주사위 돌리기 애니메이션
    let isRolling = false;
    let rollStartTime = 0;
    const rollDuration = 2000; // 2초
    const startRotation = new THREE.Euler();
    const endRotation = new THREE.Euler();

    const rollBtn = document.getElementById('rollBtn');

    rollBtn.addEventListener('click', () => {
      if (isRolling) return;

      isRolling = true;
      rollBtn.disabled = true;
      rollStartTime = performance.now();

      // 현재 회전 저장
      startRotation.copy(dodeMesh.rotation);

      // 목표 회전 설정 (여러 바퀴 + 랜덤 각도)
      endRotation.set(
        startRotation.x + (Math.random() * 4 + 3) * Math.PI * 2,
        startRotation.y + (Math.random() * 4 + 3) * Math.PI * 2,
        startRotation.z + (Math.random() * 4 + 3) * Math.PI * 2
      );
    });

    // 애니메이션 루프
    function animate() {
      requestAnimationFrame(animate);

      if (isRolling) {
        const elapsed = performance.now() - rollStartTime;
        let progress = elapsed / rollDuration;

        if (progress >= 1) {
          progress = 1;
          isRolling = false;
          rollBtn.disabled = false;
        }

        // 이지아웃 애니메이션
        const easeProgress = 1 - Math.pow(1 - progress, 3);

        // 회전 보간
        dodeMesh.rotation.x = startRotation.x + (endRotation.x - startRotation.x) * easeProgress;
        dodeMesh.rotation.y = startRotation.y + (endRotation.y - startRotation.y) * easeProgress;
        dodeMesh.rotation.z = startRotation.z + (endRotation.z - startRotation.z) * easeProgress;
      }

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>